name: Market Radar Daily

on:
  schedule:
    # GitHub schedule can be delayed; we trigger earlier (06:00 KST = 21:00 UTC)
    # and then wait until 09:00 KST inside the job.
    - cron: "0 21 * * *"
  workflow_dispatch:
    inputs:
      skip_wait:
        description: "Skip waiting until 09:00 KST (manual runs)"
        required: false
        default: "true"

jobs:
  run:
    runs-on: ubuntu-latest
    timeout-minutes: 360
    env:
      TZ: Asia/Seoul
      ENV_B64: ${{ secrets.ENV_B64 }}
      MARKET_RADER_SECRET_YML: ${{ secrets.MARKET_RADER_SECRET_YML }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: package-lock.json
      - name: Validate secrets
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GEMINI_MODEL: ${{ secrets.GEMINI_MODEL }}
          REQUIRE_GROUNDING: ${{ secrets.REQUIRE_GROUNDING }}
          SEARCHAPI_API_KEY: ${{ secrets.SEARCHAPI_API_KEY }}
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_SECURE: ${{ secrets.SMTP_SECURE }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
          MAIL_FROM: ${{ secrets.MAIL_FROM }}
          MAIL_TO: ${{ secrets.MAIL_TO }}
          MAIL_SUBJECT_PREFIX: ${{ secrets.MAIL_SUBJECT_PREFIX }}
        run: |
          set -euo pipefail

          source_provider="$(node -p "(() => { try { return require('fs').existsSync('config/research.json') ? (JSON.parse(require('fs').readFileSync('config/research.json','utf8')).source_provider || 'gemini_grounded') : 'gemini_grounded' } catch { return 'gemini_grounded' } })()")"
          echo "Detected source_provider: ${source_provider}"

          decode_b64() {
            local compact normalized mod
            compact="$(printf "%s" "${B64:-}" | tr -d ' \n\r\t')"
            [ -z "$compact" ] && return 0
            printf "%s" "$compact" | grep -Eq '^[A-Za-z0-9+/=_-]+$' || return 0
            normalized="$(printf "%s" "$compact" | tr '_-' '/+')"
            mod=$(( ${#normalized} % 4 ))
            if [ "$mod" -eq 2 ]; then
              normalized="${normalized}=="
            elif [ "$mod" -eq 3 ]; then
              normalized="${normalized}="
            elif [ "$mod" -ne 0 ]; then
              return 0
            fi
            printf "%s" "$normalized" | base64 --decode 2>/dev/null || true
          }

          required_keys=(GEMINI_API_KEY SMTP_HOST SMTP_USER SMTP_PASS MAIL_FROM MAIL_TO)
          if [ "$source_provider" = "searchapi_google_news" ]; then
            required_keys+=(SEARCHAPI_API_KEY)
          fi

          blob_name=""
          blob=""
          if [ -n "${ENV_B64:-}" ]; then
            blob_name="ENV_B64"
            blob="$ENV_B64"
          elif [ -n "${MARKET_RADER_SECRET_YML:-}" ]; then
            blob_name="MARKET_RADER_SECRET_YML"
            blob="$MARKET_RADER_SECRET_YML"
          fi

          if [ -n "$blob" ]; then
            export B64="$blob"
            decoded="$(decode_b64 || true)"
            content="$blob"
            if printf "%s" "$decoded" | grep -Eq 'GEMINI_API_KEY|SMTP_HOST|MAIL_TO'; then
              content="$decoded"
            fi

            missing=()
            for k in "${required_keys[@]}"; do
              if ! printf "%s\n" "$content" | grep -Eq "^[[:space:]]*${k}[[:space:]]*[:=]"; then
                missing+=("$k")
              fi
            done

            if [ "${#missing[@]}" -ne 0 ]; then
              echo "Missing configuration in ${blob_name}: ${missing[*]}"
              echo "- Provide dotenv lines (KEY=...), YAML mapping (KEY: ...), or base64 of either format."
              exit 1
            fi

            exit 0
          fi

          missing=()
          for k in "${required_keys[@]}"; do
            v="${!k:-}"
            if [ -z "$v" ]; then
              missing+=("$k")
            fi
          done

          if [ "${#missing[@]}" -ne 0 ]; then
            echo "Missing configuration:"
            echo "- Provide either Secrets.ENV_B64 (base64 of full .env) OR Secrets.MARKET_RADER_SECRET_YML (yaml/.env content) OR per-secret values (${missing[*]})."
            exit 1
          fi
      - name: Wait until 09:00 KST
        if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.skip_wait != 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Now (KST): $(date)"
          target="$(date -d 'today 09:00' +%s)"
          now="$(date +%s)"
          if [ "$now" -lt "$target" ]; then
            wait="$((target - now))"
            echo "Waiting ${wait}s until 09:00 KST..."
            while [ "$wait" -gt 0 ]; do
              chunk=300
              if [ "$wait" -lt "$chunk" ]; then chunk="$wait"; fi
              echo "Remaining: ${wait}s (next log in ${chunk}s) â€” $(date)"
              sleep "$chunk"
              now="$(date +%s)"
              wait="$((target - now))"
            done
          else
            echo "Already past 09:00 KST; continuing."
          fi
          echo "Start (KST): $(date)"
      - name: Install
        run: npm ci
      - name: Restore seen history cache
        uses: actions/cache@v4
        with:
          path: out/seen.json
          key: seen-v1-${{ github.run_id }}
          restore-keys: |
            seen-v1-
      - name: Run report
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GEMINI_MODEL: ${{ secrets.GEMINI_MODEL || 'gemini-2.5-flash' }}
          REQUIRE_GROUNDING: ${{ secrets.REQUIRE_GROUNDING || 'false' }}
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_SECURE: ${{ secrets.SMTP_SECURE }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
          MAIL_FROM: ${{ secrets.MAIL_FROM }}
          MAIL_TO: ${{ secrets.MAIL_TO }}
          MAIL_SUBJECT_PREFIX: ${{ secrets.MAIL_SUBJECT_PREFIX || '[Market Radar]' }}
          TZ: Asia/Seoul
        run: npm run report
