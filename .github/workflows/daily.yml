name: Market Radar Daily

on:
  schedule:
    # GitHub schedule can be delayed; we trigger earlier (06:00 KST = 21:00 UTC)
    # and then wait until 09:00 KST inside the job.
    - cron: "0 21 * * *"
  workflow_dispatch:
    inputs:
      skip_wait:
        description: "Skip waiting until 09:00 KST (manual runs)"
        required: false
        default: "true"

jobs:
  run:
    runs-on: ubuntu-latest
    timeout-minutes: 360
    env:
      TZ: Asia/Seoul
      ENV_B64: ${{ secrets.ENV_B64 }}
      MARKET_RADER_SECRET_YML: ${{ secrets.MARKET_RADER_SECRET_YML }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: package-lock.json
      - name: Validate secrets
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GEMINI_MODEL: ${{ secrets.GEMINI_MODEL }}
          REQUIRE_GROUNDING: ${{ secrets.REQUIRE_GROUNDING }}
          SEARCHAPI_API_KEY: ${{ secrets.SEARCHAPI_API_KEY }}
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_SECURE: ${{ secrets.SMTP_SECURE }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
          MAIL_FROM: ${{ secrets.MAIL_FROM }}
          MAIL_TO: ${{ secrets.MAIL_TO }}
          MAIL_SUBJECT_PREFIX: ${{ secrets.MAIL_SUBJECT_PREFIX }}
        run: |
          set -euo pipefail

          node - <<'NODE'
          const fs = require("node:fs");

          function isBlank(value) {
            return typeof value !== "string" || value.trim().length === 0;
          }

          function detectSourceProvider() {
            try {
              if (!fs.existsSync("config/research.json")) return "gemini_grounded";
              const raw = fs.readFileSync("config/research.json", "utf8");
              const config = JSON.parse(raw);
              return config?.source_provider || "gemini_grounded";
            } catch {
              return "gemini_grounded";
            }
          }

          function decodeMaybeBase64(input) {
            const compact = String(input ?? "").replace(/\s+/g, "");
            if (!compact) return null;
            if (!/^[A-Za-z0-9+/=_-]+$/.test(compact)) return null;
            const normalized = compact.replace(/-/g, "+").replace(/_/g, "/").padEnd(compact.length + ((4 - (compact.length % 4)) % 4), "=");
            try {
              return Buffer.from(normalized, "base64").toString("utf8");
            } catch {
              return null;
            }
          }

          function parseDotenv(raw) {
            const out = {};
            const lines = String(raw ?? "").replace(/\r/g, "").split("\n");
            for (const line of lines) {
              const trimmed = line.trim();
              if (!trimmed || trimmed.startsWith("#")) continue;
              const m = /^([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(.*)$/.exec(trimmed);
              if (!m) continue;
              const key = m[1];
              let value = m[2] ?? "";
              value = value.replace(/^['"]/, "").replace(/['"]$/, "");
              out[key] = value;
            }
            return out;
          }

          function parseSimpleYamlMapping(raw) {
            const out = {};
            const lines = String(raw ?? "").replace(/\r/g, "").split("\n");
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i] ?? "";
              const trimmed = line.trim();
              if (!trimmed || trimmed.startsWith("#")) continue;
              const m = /^([A-Za-z_][A-Za-z0-9_]*)\s*:\s*(.*)$/.exec(trimmed);
              if (!m) continue;
              const key = m[1];
              let value = m[2] ?? "";
              if (value === "|" || value === ">") {
                const block = [];
                for (let j = i + 1; j < lines.length; j++) {
                  const next = lines[j] ?? "";
                  if (/^[A-Za-z_][A-Za-z0-9_]*\s*:\s*/.test(next)) break;
                  block.push(next.replace(/^\s+/, ""));
                  i = j;
                }
                value = block.join("\n").trim();
              } else {
                value = value.replace(/^['"]/, "").replace(/['"]$/, "");
              }
              out[key] = value;
            }
            return out;
          }

          function hydrateFromBlob(rawBlob) {
            const decoded = decodeMaybeBase64(rawBlob);
            const useDecoded =
              decoded && /GEMINI_API_KEY|SEARCHAPI_API_KEY|SMTP_HOST|MAIL_TO/.test(decoded) ? decoded : null;
            const content = useDecoded ?? String(rawBlob ?? "");
            const dotenv = parseDotenv(content);
            const yaml = parseSimpleYamlMapping(content);
            const parsed = { ...dotenv };
            for (const [k, v] of Object.entries(yaml)) {
              if (typeof v === "string" && v.trim()) parsed[k] = v.trim();
            }
            for (const [k, v] of Object.entries(parsed)) {
              if (isBlank(process.env[k]) && typeof v === "string" && v.trim()) process.env[k] = v.trim();
            }
          }

          const sourceProvider = detectSourceProvider();
          console.log(`Detected source_provider: ${sourceProvider}`);

          const requiredKeys = ["GEMINI_API_KEY", "SMTP_HOST", "SMTP_USER", "SMTP_PASS", "MAIL_FROM", "MAIL_TO"];
          if (sourceProvider === "searchapi_google_news") requiredKeys.push("SEARCHAPI_API_KEY");

          const blobName = !isBlank(process.env.ENV_B64)
            ? "ENV_B64"
            : !isBlank(process.env.MARKET_RADER_SECRET_YML)
              ? "MARKET_RADER_SECRET_YML"
              : "";
          const blob = blobName ? process.env[blobName] : "";

          if (blobName) {
            hydrateFromBlob(blob);
            const missing = requiredKeys.filter((k) => isBlank(process.env[k]));
            if (missing.length) {
              console.error(`Missing configuration in ${blobName}: ${missing.join(" ")}`);
              console.error("- Provide dotenv lines (KEY=...), YAML mapping (KEY: value / KEY: | ...), or base64 of either format.");
              process.exit(1);
            }
            process.exit(0);
          }

          const missing = requiredKeys.filter((k) => isBlank(process.env[k]));
          if (missing.length) {
            console.error("Missing configuration:");
            console.error(
              `- Provide either Secrets.ENV_B64 (base64 of full .env) OR Secrets.MARKET_RADER_SECRET_YML (yaml/.env content) OR per-secret values (${missing.join(
                " ",
              )}).`,
            );
            process.exit(1);
          }
          NODE
      - name: Wait until 09:00 KST
        if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.skip_wait != 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Now (KST): $(date)"
          target="$(date -d 'today 09:00' +%s)"
          now="$(date +%s)"
          if [ "$now" -lt "$target" ]; then
            wait="$((target - now))"
            echo "Waiting ${wait}s until 09:00 KST..."
            while [ "$wait" -gt 0 ]; do
              chunk=300
              if [ "$wait" -lt "$chunk" ]; then chunk="$wait"; fi
              echo "Remaining: ${wait}s (next log in ${chunk}s) â€” $(date)"
              sleep "$chunk"
              now="$(date +%s)"
              wait="$((target - now))"
            done
          else
            echo "Already past 09:00 KST; continuing."
          fi
          echo "Start (KST): $(date)"
      - name: Install
        run: npm ci
      - name: Restore seen history cache
        uses: actions/cache@v4
        with:
          path: out/seen.json
          key: seen-v1-${{ github.run_id }}
          restore-keys: |
            seen-v1-
      - name: Run report
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GEMINI_MODEL: ${{ secrets.GEMINI_MODEL || 'gemini-2.5-flash' }}
          REQUIRE_GROUNDING: ${{ secrets.REQUIRE_GROUNDING || 'false' }}
          SEARCHAPI_API_KEY: ${{ secrets.SEARCHAPI_API_KEY }}
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_SECURE: ${{ secrets.SMTP_SECURE }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
          MAIL_FROM: ${{ secrets.MAIL_FROM }}
          MAIL_TO: ${{ secrets.MAIL_TO }}
          MAIL_SUBJECT_PREFIX: ${{ secrets.MAIL_SUBJECT_PREFIX || '[Market Radar]' }}
          TZ: Asia/Seoul
        run: npm run report
